#!/usr/local/bin/perl

=head1 NAME

spoc2 - Optimizing second pass of Netspoc

=head1 SYNOPSIS

spoc2 in-rules in-config out-config

=head1 DESCRIPTION

Generate device configuration from two input files.

First input file contains rules in device independent format.
Second input file is incomplete device configuration.

Optimize rules and generate access-lists in device specific format.
Combine imcomplete device configuration with access-lists into complete
device configuration.

=head1 COPYRIGHT AND DISCLAIMER

(C) 2015 by Heinz Knutzen <heinz.knutzen@googlemail.com>

http://hknutzen.github.com/Netspoc

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

=cut

use strict;
use warnings;
use JSON;
use Pod::Usage;
use open qw(:std :utf8);

sub fatal_err {
    my (@args) = @_;
    print STDERR "Error: ", @args, "\n";
    die "Aborted\n";
}

sub debug {
    print STDERR @_, "\n";
    return;
}

sub numerically { return $a <=> $b }

sub read_file {
    my ($path) = @_;
    open(my $fh, '<', $path) or fatal_err("Can't open $path");
    my $data;
    {
        local $/ = undef;
        $data = <$fh>;
    }
    close($fh);
    return $data;
}

sub read_file_lines {
    my ($path) = @_;
    open(my $fh, '<', $path) or fatal_err("Can't open $path");
    my @lines = <$fh>;
    close($fh);
    return \@lines;
}

sub ip2int {
    my ($ip) = @_;
    $ip =~ m/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/ or fatal_err("Invalid IP $ip");
    return unpack 'N', pack 'C4', $1, $2, $3, $4;
}

sub int2ip {
    my ($int) = @_;
    return sprintf "%vd", pack 'N', $int;
}

sub complement_32bit {
    my ($ip) = @_;
    return ~$ip & 0xffffffff;
}

sub ip_net2pair {
    my ($ip_net) = @_;
    my ($ip, $len) = split '/', $ip_net;
    $ip = ip2int($ip);
    return ($ip, $len);    
}

# Conversion from netmask to prefix and vice versa.
{

    # Initialize private variables of this block.
    my %mask2prefix;
    my %prefix2mask;
    for my $prefix (0 .. 32) {
        my $mask = 2**32 - 2**(32 - $prefix);
        $mask2prefix{$mask}   = $prefix;
        $prefix2mask{$prefix} = $mask;
    }

    # Convert a network mask to a prefix ranging from 0 to 32.
    sub mask2prefix {
        my $mask = shift;
        return $mask2prefix{$mask};
    }

    sub prefix2mask {
        my $prefix = shift;
        return $prefix2mask{$prefix};
    }
}

sub create_ip_obj {
    my ($ip_net) = @_;
    my ($ip, $prefix) = split '/', $ip_net;
    return { ip => ip2int($ip), mask => prefix2mask($prefix), name => $ip_net };
}

sub create_prt_obj {
    my ($descr) = @_;
    my ($proto, $i1, $i2) = split ' ', $descr;
    my $prt = { proto => $proto };
    
    if ($proto eq 'tcp' or $proto eq 'udp') {
        my ($v1, $v2) = split '-', $i1;
        $prt->{range} = [ $v1, $v2 ];
        $prt->{established} = 1 if $i2;
    }
    elsif ($proto eq 'icmp') {
        if (defined($i1)) {
            $prt->{type} = $i1;
        }
        if (defined($i2)) {
            $prt->{code} = $i2
        }
    }
    return $prt;
}

sub setup_ip_net_relation {
    my ($ip_net2obj) = @_;
    $ip_net2obj->{'0.0.0.0/0'} ||= create_ip_obj('0.0.0.0/0');
    my %mask_ip_hash;

    # Collect networks in %mask_ip_hash.
    for my $network (values %$ip_net2obj) {
        my ($ip, $mask) = @{$network}{qw(ip mask)};
        $mask_ip_hash{$mask}->{$ip} = $network;        
    }

    # Compare networks.
    # Go from smaller to larger networks.
    my @mask_list = reverse sort numerically keys %mask_ip_hash;
    while (my $mask = shift @mask_list) {

        # No supernets available
        last if not @mask_list;
        
        my $ip_hash = $mask_ip_hash{$mask};
      SUBNET:
        for my $ip (sort numerically keys %$ip_hash) {
            
            my $subnet = $ip_hash->{$ip};
            
            # Find networks which include current subnet.
            # @mask_list holds masks of potential supernets.
            for my $m (@mask_list) {
                
                my $i = $ip & $m;
                my $bignet = $mask_ip_hash{$m}->{$i} or next;
                $subnet->{up} = $bignet;

#                debug "$subnet->{name} < $bignet->{name}";
                last;
            }
        }
    }

    # Propagate content of attribute {opt_secondary} to all subnets.
    # Go from large to smaller networks.
    for my $obj (sort { $a->{mask} <=> $b->{mask} } values %$ip_net2obj) {
        my $up = $obj->{up} or next;
        my $opt_secondary = $up->{opt_secondary} or next;
        $obj->{opt_secondary} = $opt_secondary;
#        debug "secondary: $obj->{name} $opt_secondary->{name}";
    }
}

sub mark_supernets_of_need_protect {
    my ($acl_info) = @_;
    my $need_protect = $acl_info->{need_protect} or return;
    for my $interface (@$need_protect) {
        my $up = $interface->{up};
        while ($up) {
            $up->{is_supernet_of_need_protect}->{$interface} = 1;
            $up = $up->{up};
        }
    }
}

sub order_icmp {
    my ($hash, $up) = @_;

    # Handle 'icmp any'.
    if (my $prt = $hash->{''}) {
        $prt->{up} = $up;
        $up = $prt;
    }
    for my $prt (values %$hash) {

        # 'icmp any' has been handled above.
        if (!defined $prt->{type}) {
        }
        elsif (defined $prt->{code}) {
            $prt->{up} = ($hash->{ $prt->{type} } or $up);
        }
        else {
            $prt->{up} = $up;
        }
    }
    return;
}

sub order_proto {
    my ($hash, $up) = @_;
    for my $prt (values %$hash) {
        $prt->{up} = $up;
    }
    return;
}
sub order_ranges {
    my ($range_href, $up) = @_;
    my @sorted =

      # Sort by low port. If low ports are equal, sort reverse by high port.
      # I.e. larger ranges coming first, if there are multiple ranges
      # with identical low port.
      sort {
             $a->{range}->[0] <=> $b->{range}->[0]
          || $b->{range}->[1] <=> $a->{range}->[1]
      } values %$range_href;

    # Check current range [a1, a2] for sub-ranges, starting at position $i.
    # Return position of range which isn't sub-range or undef
    # if end of array is reached.
    my $check_subrange;

    $check_subrange = sub {
        my ($a, $a1, $a2, $i) = @_;
        while (1) {
            return if $i == @sorted;
            my $b = $sorted[$i];
            my ($b1, $b2) = @{ $b->{range} };

            # Neighbors
            # aaaabbbb
            if ($a2 + 1 == $b1) {

                # Mark protocol as candidate for joining of port ranges during
                # optimization.
                $a->{has_neighbor} = $b->{has_neighbor} = 1;
            }

            # Not related.
            # aaaa    bbbbb
            return $i if $a2 < $b1;

            # $a includes $b.
            # aaaaaaa
            #  bbbbb
            if ($a2 >= $b2) {
                $b->{up} = $a;
                $i = $check_subrange->($b, $b1, $b2, $i + 1);

                # Stop at end of array.
                $i or return;
                next;
            }

            # $a and $b are overlapping.
            # aaaaa
            #   bbbbbb
            my $x1 = $b1;
            my $x2 = $a2;
            my $y1 = $a2 + 1;
            my $y2 = $b2;
            fatal_err("Unexpected overlapping ranges [$a1-$a2] [$b1-$b2]");
        }
    };

    @sorted or return;
    my $index = 0;
    while (1) {
        my $a = $sorted[$index];
        $a->{up} = $up;
        my ($a1, $a2) = @{ $a->{range} };
        $index++;
        $index = $check_subrange->($a, $a1, $a2, $index) or last;
    }
    return;
}

sub setup_prt_relation {
    my ($prt2obj) = @_;
    my $prt_ip = $prt2obj->{ip} ||= create_prt_obj('ip');
    my $tcp_establ;
    my %prt_hash;
    for my $prt (values %$prt2obj) {
        my $proto = $prt->{proto};
        if ($proto eq 'tcp' or $proto eq 'udp') {

            # Handle separately.
            if ($prt->{established}) {
                $tcp_establ = $prt;
                next;
            }

            my $range = $prt->{range};
            my $key = join ':', @$range;
            $prt_hash{$proto}->{$key} = $prt;
        }
        elsif ($proto eq 'icmp') {
            my $type = $prt->{type};
            my $code = $prt->{code};
            my $key  = 
                defined $type ? (defined $code ? "$type:$code" : $type) : '';
            $prt_hash{$proto}->{$key} = $prt;
        }
        elsif ($proto eq 'ip') {
            $prt_hash{$proto} = $prt;
        }
        else {
            
            # Other protocol.
            my $key = $proto;
            $prt_hash{proto}->{$key} = $prt;
        }
    }
    my $up = $prt_ip;
    order_ranges($prt_hash{tcp}, $up);
    order_ranges($prt_hash{udp}, $up);
    order_icmp($prt_hash{icmp}, $up);
    order_proto($prt_hash{proto}, $up);

    if ($tcp_establ) {
        $tcp_establ->{up} = $prt_hash{tcp}->{'0:65535'} || $up;
    }

    return \%prt_hash;
}

sub local_optimization {
    my ($rules, $prt_ip) = @_;
    
    # For comparing rules during optimization.
    my %rule_tree;

    my $changed = 0;
    for my $rule (@$rules) {

        my ($src, $dst, $deny, $src_range, $prt) =
            @{$rule}{qw(src dst deny src_range prt)};
        $deny      ||= '';
        $src_range ||= $prt_ip;

        # Remove duplicate rules.
        if ($rule_tree{$deny}->{$src_range}->{$src}->{$dst}->{$prt}) {
            $rule    = undef;
            $changed = 1;
            next;
        }
        $rule_tree{$deny}->{$src_range}->{$src}->{$dst}->{$prt} = $rule;
    }

  RULE:
    for my $rule (@$rules) {
        next if not $rule;
        my ($deny, $src, $dst, $src_range, $prt, $log) =
            @{$rule}{qw(deny src dst src_range prt log)};
        $deny      ||= '';
        $src_range ||= $prt_ip;
        $log       ||= '';

        while (1) {
            my $src_range = $src_range;
            if (my $rule_tree = $rule_tree{$deny}) {
                while (1) {
                    my $src = $src;
                    if (my $rule_tree = $rule_tree->{$src_range}) {
                        while (1) {
                            my $dst = $dst;
                            if (my $rule_tree = $rule_tree->{$src}) {
                                while (1) {
                                    my $prt = $prt;
                                    if (my $rule_tree = $rule_tree->{$dst}) {
                                        while (1) {
                                            if (my $other = $rule_tree->{$prt})
                                            {
                                                my $o_log = $other->{log} || '';
                                                if ($rule ne $other
                                                    && $log eq $o_log)
                                                {
                                                    $rule = undef;
                                                    $changed = 1;
                                                    next RULE;
                                                }
                                            }
                                            $prt = $prt->{up} or last;
                                        }
                                    }
                                    $dst = $dst->{up} or last;
                                }
                            }
                            $src = $src->{up} or last;
                        }
                    }
                    $src_range = $src_range->{up} or last;
                }
            }
            last if $deny;
            $deny = 1;
        }

        # Implement remaining rules as secondary rule, if possible.
        $rule->{opt_secondary} or next;
        $rule->{deny} and fatal_err("Unexpected deny rule with opt_secondary");

        # Replace obj by supernet.
        if (my $supernet = $src->{opt_secondary}) {
            $src = $rule->{src} = $supernet;
        }
        if (my $supernet = $dst->{opt_secondary} and not $dst->{need_protect}) {
            $dst = $rule->{dst} = $supernet;
        }

        # Change protocol to IP.
        $rule->{prt} = $prt_ip;

        # Add new rule to rule_tree. If multiple rules are converted to the
        # same secondary rule, only the first one will be generated.
        if ($rule_tree{''}->{$prt_ip}->{$src}->{$dst}->{$prt_ip}) {

#            debug("sec delete: ", print_rule $rule);
            $rule    = undef;
            $changed = 1;
        }
        else {

#            debug("sec: ", print_rule $rule);
            # Further optimization only works if smaller rule hasn't
            # already been processed.
            $rule_tree{''}->{$prt_ip}->{$src}->{$dst}->{$prt_ip} = $rule;
        }
    }
    if ($changed) {
        $rules = [ grep { $_ } @$rules ];
    }
    return $rules;
}

# Join adjacent port ranges.
sub join_ranges {
    my ($rules, $prt_hash) = @_;
    my $changed;
    my %rule_tree = ();
  RULE:
    for my $rule (@$rules) {
        my ($deny, $src, $dst, $src_range, $prt) =
            @{$rule}{qw(deny src dst src_range prt)};

        # Only ranges which have a neighbor may be successfully optimized.
        # Currently only dst_ranges are handled.
        $prt->{has_neighbor} or next;

        $deny      ||= '';
        $src_range ||= '';
        $rule_tree{$deny}->{$src}->{$dst}->{$src_range}->{$prt} = $rule;
    }

    # %rule_tree is {deny => href, ...}
    for my $href (values %rule_tree) {

        # $href is {src => href, ...}
        for my $href (values %$href) {

            # $href is {dst => href, ...}
            for my $href (values %$href) {

                # $href is {src_range => href, ...}
                for my $src_range_ref (keys %$href) {
                    my $href = $href->{$src_range_ref};

                    # Nothing to do if only a single rule.
                    next if values %$href == 1;

                    # Values of %$href are rules with identical
                    # deny/src/dst/src_range and a TCP or UDP protocol.
                    #
                    # Collect rules with identical log type and
                    # identical protocol.
                    my %key2rules;
                    for my $rule (values %$href) {
                        my $key = $rule->{prt}->{proto};
                        if (my $log = $rule->{log}) {
                            $key .= ",$log";
                        }
                        push @{ $key2rules{$key} }, $rule;
                    }

                    for my $rules (values %key2rules) {

                        # When sorting these rules by low port number,
                        # rules with adjacent protocols will placed
                        # side by side. There can't be overlaps,
                        # because they have been split in function
                        # 'order_ranges'. There can't be sub-ranges,
                        # because they have been deleted as redundant
                        # already.
                        my @sorted = sort {
                            $a->{prt}->{range}->[0]
                                <=> $b->{prt}->{range}->[0]
                        } @$rules;
                        @sorted >= 2 or next;
                        my $i      = 0;
                        my $rule_a = $sorted[$i];
                        my ($a1, $a2) = @{ $rule_a->{prt}->{range} };
                        while (++$i < @sorted) {
                            my $rule_b = $sorted[$i];
                            my ($b1, $b2) = @{ $rule_b->{prt}->{range} };
                            if ($a2 + 1 == $b1) {
                                
                                # Found adjacent port ranges.
                                if (my $range = delete $rule_a->{range}) {
                                    
                                    # Extend range of previous two or
                                    # more elements.
                                    $range->[1] = $b2;
                                    $rule_b->{range} = $range;
                                }
                                else {
                                    
                                    # Combine ranges of $rule_a and $rule_b.
                                    $rule_b->{range} = [ $a1, $b2 ];
                                }
                                
                                # Mark previous rule as deleted.
                                $rule_a->{deleted} = 1;
                                $changed = 1;
                            }
                            $rule_a = $rule_b;
                            ($a1, $a2) = ($b1, $b2);
                        }
                    }
                }
            }
        }
    }
    if ($changed) {
        my @rules;
        for my $rule (@$rules) {

            # Check and remove attribute 'deleted'.
            next if delete $rule->{deleted};

            # Process rules with joined port ranges.
            # Remove auxiliary attribute {range} from rules.
            if (my $range = delete $rule->{range}) {
                my $prt   = $rule->{prt};
                my $proto = $prt->{proto};
                my $key   = join(':', @$range);

                # Try to find existing prt with matching range.
                # This is needed for find_objectgroups to work.
                my $new_prt = $prt_hash->{$proto}->{$key};
                if (not $new_prt) {
                    $new_prt = {
                        proto => $proto,
                        range => $range
                    };
                    $prt_hash->{$proto}->{$key} = $new_prt;
                }
                my $new_rule = { %$rule, prt => $new_prt };
                push @rules, $new_rule;
            }
            else {
                push @rules, $rule;
            }
        }
        $rules = \@rules;
    }
    return $rules;
}

# Add deny and permit rules at device which filters only locally.
sub add_local_deny_rules {
    my ($acl_info, $router_data) = @_;
    my ($filter_only, $do_objectgroup) = 
        @{$router_data}{qw(filter_only do_objectgroup)};
    my ($network_00, $prt_ip) = @{$acl_info}{qw(network_00 prt_ip)};
    my $rules = $acl_info->{rules};
    
    my $src_networks = 
        $acl_info->{filter_any_src} ? [$network_00] : $filter_only;

    if ($do_objectgroup) {

        my $group_or_single = sub {
            my ($obj_list) = @_;
            if (1 == @$obj_list) {
                return $obj_list->[0];
            }

            # Reuse object-group at all interfaces.
            elsif (my $group = $router_data->{filter_only_group}) {
                return $group;
            }
            else {
                $group = { name => "g$router_data->{obj_group_counter}",
                           elements => [ map { $_->{name} } @$obj_list ] };
                $router_data->{obj_group_counter}++;
                push @{ $acl_info->{object_groups} }, $group;
                $router_data->{filter_only_group} = $group;
                return $group;
            }
        };
        push(@$rules, 
             { deny => 1, 
               src => $group_or_single->($src_networks), 
               dst => $group_or_single->($filter_only), 
               prt => $prt_ip });
    }
    else {
        for my $src (@$src_networks) {
            for my $dst (@$filter_only) {
                push(@$rules,
                     { deny => 1, src => $src, dst => $dst, prt => $prt_ip });
            }
        }
    }
    push @$rules, { src => $network_00, dst => $network_00, prt => $prt_ip };
    return;
}

my $min_object_group_size = 2;

sub find_objectgroups {
    my ($acl_info, $router_data) = @_;
    my $size2first2group = $router_data->{obj_groups_hash};

    # Leave 'intf_rules' untouched, because
    # - these rules are ignored at ASA, PIX,
    # - NX-OS needs them individually when optimizing need_protect.
    my $rules = $acl_info->{rules};

    # Find object-groups in src / dst of rules.
    for my $this ('src', 'dst') {
        my $that = $this eq 'src' ? 'dst' : 'src';
        my %group_rule_tree;

        # Find groups of rules with identical
        # deny, src_range, prt, log, src/dst and different dst/src.
        for my $rule (@$rules) {
            my $deny      = $rule->{deny} || '';
            my $that      = $rule->{$that}->{name};
            my $this      = $rule->{$this}->{name};
            my $src_range = $rule->{src_range} || '';
            my $prt       = $rule->{prt};
            my $key       = "$deny,$that,$src_range,$prt";
            if (my $log = $rule->{log}) {
                $key .= ",$log";
            }
            $group_rule_tree{$key}->{$this} = $rule;
        }

        # Find groups >= $min_object_group_size,
        # mark rules belonging to one group,
        # put groups into an array / hash.
        for my $href (values %group_rule_tree) {

            # $href is {dst/src => rule, ...}
            keys %$href >= $min_object_group_size or next;

            my $glue = {

                # Indicator, that no further rules need to be processed.
                active => 0,

                # object-key => rule, ...
                hash => $href
            };

            # All this rules have identical deny, src_range, prt
            # and dst/src and shall be replaced by a single new
            # rule referencing an object group.
            for my $rule (values %$href) {
                $rule->{group_glue} = $glue;
            }
        }

        my $build_group = sub {
            my ($obj_key_list) = @_;
            my $group = { name => "g$router_data->{obj_group_counter}", 
                          elements => $obj_key_list };
            $router_data->{obj_group_counter}++;

            # Store group for later printing of its definition.
            push @{ $acl_info->{object_groups} }, $group;
            return $group;
        };

        # Find group with identical elements or define a new one.
        my $get_group = sub {
            my ($glue) = @_;
            my $hash   = $glue->{hash};

            # Keys are "i.i.i.i/len".
            # Sort keys by IP and prefixlen for normalized output and
            # to get some "first" element.
            my @obj_key_list  =
                map { $_->[0] }
                sort { $a->[1] <=> $b->[1] || $a->[2] <=> $b->[2] }
                map { [ $_, ip_net2pair($_) ] }
                keys %$hash;

            my $first = $obj_key_list[0];
            my $size  = @obj_key_list;

            # Find group with identical elements.
          HASH:
            for my $group_hash (
                @{ $size2first2group->{$size}->{$first} })
            {
                my $href = $group_hash->{hash};

                # Check elements for equality.
                for my $key (@obj_key_list) {
                    $href->{$key} or next HASH;
                }

                # Found $group_hash with matching elements.
                return $group_hash->{group};
            }

            # No group hash found, build new group hash with new group.
            my $group      = $build_group->(\@obj_key_list);
            my $group_hash = { hash  => $hash, group => $group, };
            push(@{ $size2first2group->{$size}->{$first} }, $group_hash);
            return $group;
        };

        # Build new list of rules using object groups.
        my @new_rules;
        for my $rule (@$rules) {
            if (my $glue = delete $rule->{group_glue}) {
                if ($glue->{active}) {
                    next;
                }
                my $group = $get_group->($glue);
                $glue->{active} = 1;
                $rule->{$this} = $group;
            }
            push @new_rules, $rule;
        }
        $rules = \@new_rules;
    }
    $acl_info->{rules} = $rules;
    return;
}

sub add_protect_rules {
    my ($acl_info, $router_data, $has_final_permit) = @_;
    my $need_protect = $acl_info->{need_protect} or return;
    my ($network_00, $prt_ip) = @{$acl_info}{qw(network_00 prt_ip)};

    # Add deny rules to protect own interfaces.
    # If a rule permits traffic to a directly connected network behind
    # the device, this would accidently permit traffic to an interface
    # of this device as well.

    # To be added deny rule is needless if there is a rule which
    # permits any traffic to the interface.
    # This permit rule can be deleted if there is a permit any any rule.
    my %no_protect;
    my %seen;
    my $changed;
    for my $rule (@{ $acl_info->{intf_rules} }) {
        next if $rule->{deny};
        next if $rule->{src} ne $network_00;
        next if $rule->{prt} ne $prt_ip;
        my $dst = $rule->{dst};
        $no_protect{$dst} = 1 if $dst->{need_protect};

        if ($has_final_permit) {
            $rule    = undef;
            $changed = 1;
        }
    }
    if ($changed) {
        $acl_info->{intf_rules} = [ grep { $_ } @{ $acl_info->{intf_rules} } ];
    }

    # Deny rule is needless if there is no such permit rule.
    # Try to optimize this case.
    my %need_protect;
    for my $rule (@{ $acl_info->{rules} }) {
        next if $rule->{deny};
        next if $rule->{prt}->{established};
        my $dst = $rule->{dst};
        my $hash = $dst->{is_supernet_of_need_protect} or next;
        for my $intf (@$need_protect) {
            if ($hash->{$intf}) {
                $need_protect{$intf} = $intf;
            }
        }
    }

    # Protect own interfaces.
    for my $interface (@$need_protect) {
        if (    $no_protect{$interface}
            or  not $need_protect{$interface}
            and not $has_final_permit)
        {
            next;
        }

        push @{ $acl_info->{intf_rules} }, {
            deny => 1,
            src  => $network_00,
            dst  => $interface,
            prt  => $prt_ip
        };
    }
}

# Check if last is rule is 'permit ip any any'.
sub check_final_permit {
    my ($acl_info, $router_data) = @_;
    my $rules = $acl_info->{rules};
    @$rules or return;
    my ($net_00, $prt_ip) = @{$acl_info}{qw(network_00 prt_ip)};
    my ($deny, $src, $dst, $prt) = @{ $rules->[-1] }{qw(deny src dst prt)};
    return !$deny && $src eq $net_00 && $dst eq $net_00 && $prt eq $prt_ip;
}

# Add 'deny|permit ip any any' at end of ACL.
sub add_final_permit_deny_rule {
    my ($acl_info, $router_data) = @_;
    my $rules = $acl_info->{rules};
    $acl_info->{add_deny} or $acl_info->{add_permit} or return;

    my ($net_00, $prt_ip) = @{$acl_info}{qw(network_00 prt_ip)};
    my $rule = { src => $net_00, dst => $net_00, prt => $prt_ip };
    if ($acl_info->{add_deny}) {
        $rule->{deny} = 1;
        if (my $log_deny = $router_data->{log_deny}) {
            $rule->{log} = $log_deny;
        }
    }
    push @{ $acl_info->{rules} }, $rule;

    return;
}

sub prepare_acls {
    my ($path) = @_;
    my $router_data = from_json(read_file($path));
    my ($model, $acls, $filter_only, $do_objectgroup) =
        @{$router_data}{qw(model acls filter_only do_objectgroup)};
    
    # Reuse identical groups from different ACLs.
    $router_data->{obj_groups_hash} = {};
    $router_data->{obj_group_counter} = 0;

    my $ip_net2obj = {};
    my $prt2obj    = {};

    if ($filter_only) {
        for my $ip_net (@$filter_only) {
            my $obj = $ip_net2obj->{$ip_net} ||= create_ip_obj($ip_net);

            # Update original array.
            $ip_net = $obj;
        }
    }
            
    for my $acl_info (@$acls) {
        for my $what (qw(intf_rules rules)) {
            my $rules = $acl_info->{$what} or next;
            for my $rule (@$rules) {
                for my $where (qw(src dst)) {
                    my $ip_net = $rule->{$where};
                    my $obj = $ip_net2obj->{$ip_net} ||= create_ip_obj($ip_net);
                    $rule->{$where} = $obj;
                }
                for my $where (qw(src_range prt)) {
                    my $prt = $rule->{$where} or next;
                    my $obj = $prt2obj->{$prt} ||= create_prt_obj($prt);
                    $rule->{$where} = $obj;
                }
            }
        }
        if (my $opt_secondary = $acl_info->{opt_secondary}) {
            for my $ip_net (@$opt_secondary) {
                my $obj = $ip_net2obj->{$ip_net} ||= create_ip_obj($ip_net);
                $obj->{opt_secondary} = $obj;
                $ip_net = $obj;
            }
        }
        if (my $need_protect = $acl_info->{need_protect}) {
            for my $ip_net (@$need_protect) {
                my $obj = $ip_net2obj->{$ip_net} ||= create_ip_obj($ip_net);
                $obj->{need_protect} = 1;
                $ip_net = $obj;
            }
        }

        setup_ip_net_relation($ip_net2obj);
        $acl_info->{network_00} = $ip_net2obj->{'0.0.0.0/0'};
        mark_supernets_of_need_protect($acl_info);
        
        my $prt_hash = setup_prt_relation($prt2obj);
        my $prt_ip = $acl_info->{prt_ip} = $prt2obj->{ip};
        
        for my $what (qw(intf_rules rules)) {
            my $rules = $acl_info->{$what} or next;
            if ($model eq 'Linux') {
                $rules = find_chains($rules);
            }
            else {
                $rules = local_optimization($rules, $prt_ip);
    
                # Join adjacent port ranges. This must be called after
                # local optimization, because protocols will be
                # overlapping again after joining.
                $rules = join_ranges($rules, $prt_hash);
            }
            $acl_info->{$what} = $rules;
        }

        my $has_final_permit = check_final_permit($acl_info, $router_data);
        add_protect_rules($acl_info, $router_data, 
                          $has_final_permit || $acl_info->{add_permit});
        if ($do_objectgroup) {
            find_objectgroups($acl_info, $router_data);
        }
        if ($filter_only) {
            add_local_deny_rules($acl_info, $router_data);
        }
        elsif (not $has_final_permit) {
            add_final_permit_deny_rule($acl_info, $router_data);
        }
    }
    return $router_data;
}

# Given IP/prefix or group name, return its address in Cisco syntax.
sub cisco_acl_addr {
    my ($key, $model) = @_;
    my ($ip, $prefix) = split '/', $key;

    # Reference object group.
    if ($ip =~ /^[^0-9]/) {
        my $keyword = $model eq 'NX-OS' ? 'addrgroup' : 'object-group';
        return "$keyword $key";
    }
    elsif ($prefix == 0) {
        return "any";
    }
    elsif ($model eq 'NX-OS') {
        return $key;
    }
    else {
        if (32 == $prefix) {
            return "host $ip";
        }
        else {
            my $mask = prefix2mask($prefix);

            # Inverse mask bits.
            $mask = complement_32bit($mask) if $model =~ /^(:?NX-OS|IOS)/;
            my $mask_code = int2ip($mask);
            return "$ip $mask_code";
        }
    }
}

sub print_object_groups {
    my ($groups, $model) = @_;
    my $keyword = $model eq 'NX-OS'
                ? 'object-group ip address'
                : 'object-group network';
    for my $group (@$groups) {

        my $numbered = 10;
        print "$keyword $group->{name}\n";
        for my $key (@{ $group->{elements} }) {

            # Reject network with mask = 0 in group.
            # This occurs if optimization didn't work correctly.
            $key eq '0.0.0.0/0'
                and fatal_err(
                    "Unexpected network with mask 0 in object-group"
                );
            my $adr = cisco_acl_addr($key, $model);
            if ($model eq 'NX-OS') {
                print " $numbered $adr\n";
                $numbered += 10;
            }
            elsif ($model eq 'ACE') {
                print " $adr\n";
            }
            else {
                print " network-object $adr\n";
            }
        }
    }
}

# Returns 3 values for building a Cisco ACL:
# permit <val1> <src> <val2> <dst> <val3>
sub cisco_prt_code {
    my ($src_range, $prt, $model) = @_;
    my $proto = $prt->{proto};

    if ($proto eq 'ip') {
        return ('ip', undef, undef);
    }
    elsif ($proto eq 'tcp' or $proto eq 'udp') {
        my $port_code = sub {
            my ($range_obj) = @_;
            my ($v1, $v2) = @{ $range_obj->{range} };
            if ($v1 == $v2) {
                return ("eq $v1");
            }
            elsif ($v1 == 1 and $v2 == 65535) {
                return (undef);
            }
            elsif ($v2 == 65535) {
                return 'gt ' . ($v1 - 1);
            }
            elsif ($v1 == 1) {
                return 'lt ' . ($v2 + 1);
            }
            else {
                return ("range $v1 $v2");
            }
        };
        my $dst_prt = $port_code->($prt);
        if (my $established = $prt->{established}) {
            if (defined $dst_prt) {
                $dst_prt .= ' established';
            }
            else {
                $dst_prt = 'established';
            }
        }
        my $src_prt = $src_range && $port_code->($src_range);
        return ($proto, $src_prt, $dst_prt);
    }
    elsif ($proto eq 'icmp') {
        if (defined(my $type = $prt->{type})) {
            if (defined(my $code = $prt->{code})) {
                if ($model =~ /^(:?ASA|PIX)$/) {

                    # PIX can't handle the ICMP code field.
                    # If we try to permit e.g. "port unreachable",
                    # "unreachable any" could pass the PIX.
                    return ($proto, undef, $type);
                }
                else {
                    return ($proto, undef, "$type $code");
                }
            }
            else {
                return ($proto, undef, $type);
            }
        }
        else {
            return ($proto, undef, undef);
        }
    }
    else {
        return ($proto, undef, undef);
    }
}

sub print_cisco_acl {
    my ($acl_info, $model) = @_;
    my $intf_rules = $acl_info->{intf_rules} || [];
    my $rules = $acl_info->{rules};
    my $name = $acl_info->{name};
    my $numbered = 10;
    my $prefix;
    if ($model eq 'IOS') {
        $prefix = '';
        print "ip access-list extended $name\n";
    }
    elsif ($model eq 'NX-OS') {
        $prefix = '';
        print "ip access-list $name\n";
    }
    elsif ($model eq 'ASA' || $model eq 'ACE') {
        $prefix = "access-list $name extended";
    }
    elsif ($model eq 'PIX') {
        $prefix = "access-list $name";
    }
    else {
        fatal_err("Unexpected model $model");
    }

    for my $rule (@$intf_rules, @$rules) {
        my ($deny, $src, $dst, $src_range, $prt) =
          @{$rule}{qw(deny src dst src_range prt)};
        my $action = $deny ? 'deny' : 'permit';
        my $skey = $src->{name};
        my $dkey = $dst->{name};

        my ($proto_code, $src_port_code, $dst_port_code) =
          cisco_prt_code($src_range, $prt, $model);
        my $result = "$prefix $action $proto_code";
        $result .= ' ' . cisco_acl_addr($skey, $model);
        $result .= " $src_port_code" if defined $src_port_code;
        $result .= ' ' . cisco_acl_addr($dkey, $model);
        $result .= " $dst_port_code" if defined $dst_port_code;

        if (my $log = $rule->{log}) {
            $result .= " $log";
        }

        # Add line numbers.
        if ($model eq 'NX-OS') {
            $result = " $numbered$result";
            $numbered += 10;
        }
        print "$result\n";
    }
    return;
}

sub print_acl {
    my ($acl_info, $model) = @_;

    if ($model eq 'Linux') {
        print_iptables_acl($acl_info);
    }
    else {
        if (my $groups = $acl_info->{object_groups}) {
            print_object_groups($groups, $model);
        }    
        print_cisco_acl($acl_info, $model);
    }
}

sub print_combined {
    my ($config, $router_data, $out_path) = @_;

    # Redirect print statements to $out_path.
    ## no critic (RequireBriefOpen)
    open(my $out_fd, '>', $out_path)
        or fatal_err("Can't open $out_path for writing: $!");
    select $out_fd;

    my ($acls, $model) = @{$router_data}{qw(acls model)};
    my %acl_hash = map { $_->{name} => $_ } @$acls;

    # Print config and insert printed ACLs at "#insert <name>" markers.
    for my $line (@$config) {

        # Print ACL.
        if (my ($acl_name) = ($line =~ /^#insert (.*)\n$/)) {
            my $acl_info = $acl_hash{$acl_name} or 
                fatal_err("Unexpected ACL $acl_name");
            print_acl($acl_info, $model);
        }

        # Print unchanged config line.
        else {
            print $line;
        }
    }   

    select STDOUT;
    close $out_fd or fatal_err("Can't close $out_path: $!");
    ## use critic

    return;
}

sub pass2 {
    my ($args) = @_;
    my ($rules_path, $config_path, $out_path, @extra) = @$args;
    ($rules_path && $config_path && $out_path || @extra) or pod2usage(2);
    my $router_data = prepare_acls($rules_path);
    my $config = read_file_lines($config_path);
    print_combined($config, $router_data, $out_path);
}

pass2(\@ARGV);
